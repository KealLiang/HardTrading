# 概念分组与龙头股筛选逻辑说明

## 一、概念分组逻辑

### 1.1 分组流程概述

概念分组在 `identify_first_significant_board` 函数中完成，主要流程如下：

```
识别显著连板股票 → 收集所有概念 → 确定热门概念 → 为每只股票分配概念组 → 计算概念优先级 → 排序输出
```

### 1.2 详细步骤

#### 第一步：收集所有概念信息（代码位置：813-818行）

从 `result_df` 中遍历所有股票，提取每只股票的概念字段，汇总到 `all_concepts` 列表中。

```python
for _, row in result_df.iterrows():
    concept_str = row.get('concept', '')
    if pd.notna(concept_str) and concept_str:
        concepts = extract_reasons(concept_str)  # 提取概念列表
        all_concepts.extend(concepts)
```

#### 第二步：确定全局热门概念（代码位置：821行）

调用 `get_reason_colors()` 函数，根据概念出现频率和用户指定的优先概念，确定全局热门概念列表。

```python
global_reason_colors, global_top_reasons = get_reason_colors(
    all_concepts, 
    priority_reasons=priority_reasons  # 用户指定的优先概念
)
```

**热门概念排序规则**：
- 优先级1：用户通过 `priority_reasons` 参数指定的概念
- 优先级2：按出现频率倒序排列的其他概念

#### 第三步：为每只股票分配概念组（代码位置：830-853行）

通过 `get_global_concept_group()` 函数为每只股票确定所属的概念组：

```python
def get_global_concept_group(row):
    # 1. 检查是否为【默默上涨】股票
    if row.get('entry_type') == 'momo_shangzhang':
        return "默默上涨"
    
    # 2. 提取股票的所有概念
    concept_str = row.get('concept', '')
    concepts = extract_reasons(concept_str)
    
    # 3. 优先从热门概念列表中匹配
    concepts_set = set(concepts)
    for top_reason in global_top_reasons:  # 按热门度顺序遍历
        if top_reason in concepts_set:
            return top_reason  # 返回第一个匹配的热门概念
    
    # 4. 如果没有热门概念，返回第一个概念
    return concepts[0] if concepts else "其他"
```

**分组规则**：
- 特殊分组：【默默上涨】股票单独成组
- 热门概念优先：如果股票包含多个概念，优先归入热门度最高的概念组
- 兜底处理：既不是热门概念也没有概念的股票归入"其他"组

#### 第四步：计算概念优先级（代码位置：856-879行）

为所有概念组分配显示优先级，用于排序：

```python
# 1. 统计每个概念组的股票数量
concept_counts = result_df['concept_group'].value_counts().to_dict()

# 2. 分离热门概念和非热门概念
non_hot_concepts = [concept for concept in concept_counts.keys()
                    if concept not in global_top_reasons and concept != "其他"]
non_hot_concepts_sorted = sorted(non_hot_concepts, 
                                key=lambda x: concept_counts[x], 
                                reverse=True)

# 3. 构建优先级映射
concept_priority = {}

# 热门概念：保持原有优先级（0, 1, 2, ...）
for i, concept in enumerate(global_top_reasons):
    concept_priority[concept] = i

# 非热门概念：按股票数量倒序排列，优先级在热门概念之后
start_priority = len(global_top_reasons)
for i, concept in enumerate(non_hot_concepts_sorted):
    concept_priority[concept] = start_priority + i

# 【默默上涨】：排在非热门概念之后，"其他"之前
concept_priority["默默上涨"] = start_priority + len(non_hot_concepts_sorted)

# "其他"：排在最后
concept_priority["其他"] = start_priority + len(non_hot_concepts_sorted) + 1
```

**优先级顺序**：
1. 用户指定的优先概念（按指定顺序）
2. 其他热门概念（按频率倒序）
3. 非热门概念（按股票数量倒序）
4. 【默默上涨】分组
5. "其他"分组

#### 第五步：排序输出（代码位置：884-888行）

按多个维度对股票进行排序：

```python
result_df = result_df.sort_values(
    by=['first_significant_date',    # 首次显著连板日期（升序）
        'concept_priority',           # 概念优先级（升序）
        'concept_group',              # 概念组名称（升序）
        'board_level_at_first'],      # 首次连板天数（降序）
    ascending=[True, True, True, False]
)
```

---

## 二、龙头股筛选逻辑

### 2.1 筛选流程概述

龙头股筛选在 `select_leader_stocks_from_concept_groups` 函数中完成（代码位置：3619-3729行）：

```
按概念分组 → 计算股票指标 → 应用筛选条件 → 组内排序 → 选出TopN → 全局排序
```

### 2.2 筛选参数配置

```python
# 龙头股筛选相关参数（代码位置：79-87行）
MIN_BOARD_LEVEL_FOR_LEADER = 2              # 龙头股最低连板数门槛
MIN_SHORT_PERIOD_CHANGE_FOR_LEADER = 20.0  # 龙头股最低短周期涨幅门槛（%）
MIN_LONG_PERIOD_CHANGE_FOR_LEADER = 60.0   # 龙头股最低长周期涨幅门槛（%）
TOP_N_LEADERS_PER_CONCEPT = 2               # 每个概念选出的龙头股数量
```

### 2.3 详细步骤

#### 第一步：计算股票指标（代码位置：3641-3674行）

为每只股票计算以下指标：

```python
def calculate_additional_metrics(row):
    stock_code = row['stock_code']
    
    # 1. 计算最高连板数
    max_board_level = calculate_max_board_level(row['all_board_data'])
    
    # 2. 计算短周期涨跌幅（默认10天）
    end_date = date_mapping.get(formatted_trading_days[-1])
    start_date = get_n_trading_days_before(end_date, period_days)
    short_change = calculate_stock_period_change(stock_code, start_date, end_date)
    
    # 3. 长周期涨跌幅在前面已经计算（默认30天）
    # long_period_change 列已存在
    
    return max_board_level, short_change
```

**关键指标**：
- `max_board_level`：股票在分析周期内的最高连板数
- `short_period_change`：短周期涨跌幅（默认10天）
- `long_period_change`：长周期涨跌幅（默认30天）

#### 第二步：按概念分组筛选（代码位置：3677-3712行）

对每个概念组分别应用筛选条件：

```python
for concept_group, group_df in temp_df.groupby('concept_group'):
    # 筛选条件1：连板数门槛
    board_mask = group_df['max_board_level'] >= MIN_BOARD_LEVEL_FOR_LEADER  # >= 2板
    
    # 筛选条件2：涨幅门槛（短周期OR长周期满足一个即可）
    short_mask = group_df['short_period_change'] >= MIN_SHORT_PERIOD_CHANGE_FOR_LEADER  # >= 20%
    long_mask = group_df['long_period_change'] >= MIN_LONG_PERIOD_CHANGE_FOR_LEADER    # >= 60%
    change_mask = short_mask | long_mask  # 逻辑或
    
    # 组合筛选条件（逻辑与）
    qualified_df = group_df[board_mask & change_mask]
```

**筛选条件**：
- **必须条件**：最高连板数 >= 2
- **满足其一**：
  - 短周期涨幅 >= 20%，OR
  - 长周期涨幅 >= 60%

#### 第三步：组内排序（代码位置：3701-3704行）

对每个概念组内符合条件的股票进行排序：

```python
qualified_df = qualified_df.sort_values(
    by=['long_period_change',      # 长周期涨跌幅（降序）
        'max_board_level',         # 最高连板数（降序）
        'short_period_change'],    # 短周期涨跌幅（降序）
    ascending=[False, False, False]
)
```

**排序优先级**：
1. 优先级1：长周期涨幅越高越好
2. 优先级2：最高连板数越高越好
3. 优先级3：短周期涨幅越高越好

#### 第四步：选出TopN（代码位置：3707行）

从每个概念组中选出排名前N的股票作为龙头：

```python
leaders = qualified_df.head(TOP_N_LEADERS_PER_CONCEPT)  # 默认选出前2只
```

#### 第五步：全局排序（代码位置：3724-3727行）

将所有概念组的龙头股汇总后，按全局规则重新排序：

```python
leader_df = leader_df.sort_values(
    by=['first_significant_date',  # 首次显著连板日期（升序）
        'concept_priority',        # 概念优先级（升序）
        'board_level_at_first'],   # 首次连板天数（降序）
    ascending=[True, True, False]
)
```

**全局排序规则**：
- 按首次入选日期分组展示（时间线）
- 同一天内，概念优先级高的在前
- 同一概念组内，首次连板天数高的在前

---

## 三、使用示例

### 3.1 启用龙头股工作表

在调用 `build_ladder_chart` 函数时，设置 `create_leader_sheet=True`：

```python
build_ladder_chart(
    start_date="20240101",
    end_date="20240131",
    create_leader_sheet=True,  # 启用龙头股工作表
    priority_reasons=["AI", "芯片", "新能源"]  # 可选：指定优先概念
)
```

### 3.2 调整龙头股筛选参数

修改全局配置（代码位置：79-87行）：

```python
MIN_BOARD_LEVEL_FOR_LEADER = 3              # 提高连板门槛到3板
MIN_SHORT_PERIOD_CHANGE_FOR_LEADER = 30.0  # 提高短周期涨幅门槛到30%
MIN_LONG_PERIOD_CHANGE_FOR_LEADER = 80.0   # 提高长周期涨幅门槛到80%
TOP_N_LEADERS_PER_CONCEPT = 3               # 每个概念选出3只龙头
```

---

## 四、核心函数调用关系

```
build_ladder_chart()
├── identify_first_significant_board()
│   ├── get_all_stocks()                    # 获取所有股票池
│   ├── analyze_stocks_for_significant_boards()  # 分析显著连板
│   └── [概念分组逻辑]
│       ├── collect_stock_concepts()        # 收集概念
│       ├── get_reason_colors()             # 确定热门概念
│       ├── get_global_concept_group()      # 分配概念组
│       └── 概念优先级计算与排序
│
├── create_concept_grouped_sheet_content()  # 创建按概念分组的工作表
│   └── fill_data_rows_with_concept_groups()  # 按概念分组填充数据
│
└── create_leader_stocks_sheet_content()    # 创建龙头股工作表（可选）
    └── select_leader_stocks_from_concept_groups()  # 筛选龙头股
        ├── calculate_additional_metrics()  # 计算指标
        ├── 按概念分组应用筛选条件
        ├── 组内排序
        ├── 选出TopN
        └── 全局排序
```

---

## 五、输出示例

### 5.1 概念分组工作表示例

```
【AI】
股票代码  题材概念    股票简称   近10日/近30日  2024/01/02  2024/01/03  ...
000001    [AI,芯片]   平安银行   25.3/68.5      5板        停牌        ...
000002    [AI]        万科A      18.2/45.3      3板        4.56%       ...

【芯片】
股票代码  题材概念    股票简称   近10日/近30日  2024/01/02  2024/01/03  ...
000003    [芯片]      中兴通讯   32.1/78.2      4板        5板         ...

【默默上涨】
股票代码  题材概念           股票简称   近10日/近30日  2024/01/02  2024/01/03  ...
000004    成交额:15亿...     格力电器   15.6/35.2      3.21%       4.12%       ...
```

### 5.2 龙头股工作表示例

每个概念组只显示前2只（默认）龙头股：

```
股票代码  题材概念    股票简称   近10日/近30日  2024/01/02  2024/01/03  ...
000001    [AI,芯片]   平安银行   25.3/68.5      5板        停牌        ...  ← AI组龙头1
000002    [AI]        万科A      18.2/45.3      3板        4.56%       ...  ← AI组龙头2
000003    [芯片]      中兴通讯   32.1/78.2      4板        5板         ...  ← 芯片组龙头1
```

---

## 六、注意事项

1. **概念分组的唯一性**：每只股票只能归入一个概念组，即使它包含多个概念标签
2. **龙头筛选的严格性**：必须同时满足连板数门槛和涨幅门槛（二选一）
3. **长周期涨幅的重要性**：龙头股排序时，长周期涨幅是最重要的指标
4. **龙头工作表的独立性**：龙头股工作表按日期独立保存，文件名格式为"龙头MMDD"
5. **【默默上涨】的特殊性**：该分组不参与龙头股筛选，仅在概念分组工作表中展示 